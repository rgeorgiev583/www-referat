<!DOCTYPE html>
<html>
  <head>
    <title>WebAssembly</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-solarized-light.min.css"/>
  </head>
<body><p><a name="title"></a></p>
<h1 id="webassembly"><a class="header-link" href="#webassembly"></a>WebAssembly</h1>
<p><a name="intro"></a></p>
<h2 id="въведение"><a class="header-link" href="#въведение"></a>Въведение</h2>
<p><strong><em>WebAssembly</em></strong>, или <em>wasm</em>, е платформа (включваща в себе си <em>виртуална машина</em>) за компилация и изпълнение на клиентски (т.е. браузър-базирани) уеб приложения.<sup><a href="#ref-website-wasm">[1]</a></sup></p>
<p><a name="features"></a></p>
<h2 id="предимства"><a class="header-link" href="#предимства"></a>Предимства</h2>
<p><em>WebAssembly</em> има следните основни предимства:</p>
<ul class="list">
<li>преносим е (изпълнява се на множество различни хардуерни платформи, операционни системи, браузъри и т.н.);</li>
<li>оптимизиран е откъм размер на генерираните изпълними файлове и откъм тяхното време на зареждане и изпълнение;</li>
<li>отворен стандарт е на <em>W3C</em> общността, която включва представители на всички най-използвани браузъри.<sup><a href="#ref-website-wasmcg">[2]</a></sup></li>
</ul>
<p><a name="features-fast"></a></p>
<h3 id="*webassembly*-е-ефективен-и-бърз"><a class="header-link" href="#*webassembly*-е-ефективен-и-бърз"></a><em>WebAssembly</em> е ефективен и бърз</h3>
<p>Платформата <em>WebAssembly</em> е базирана на <em>стекова виртуална машина</em><sup><a href="#ref-wp-stackmachine">[3]</a></sup>.  Нейният <a href="#semantics">байткод</a> използва <a href="#binaryencoding">бинарен формат за изпълними файлове</a>, който е оптимизиран откъм размер и време за изпълнение.
<em>WebAssembly</em> се стреми да постигне скорост на изпълнение, сходна с тази на софтуера, изпълняван директно (<em>native</em>) върху реалния хардуер на машината.  За да постигне тази цел по ефективен начин, той се възползва от множеството способности за оптимизация, вградени в хардуера на многото поддържани от него платформи.</p>
<p><a name="features-safe"></a></p>
<h3 id="*webassembly*-е-безопасен"><a class="header-link" href="#*webassembly*-е-безопасен"></a><em>WebAssembly</em> е безопасен</h3>
<p><em>WebAssembly</em> включва в себе си изолирана среда за изпълнение (<em>sandboxed execution environment</em><sup><a href="#ref-wp-sandbox">[4]</a></sup>), която гарантира безопасността на достъпа до паметта.  При вграждане в уеб страници <em>WebAssembly</em> гарантира следването на <em>same-origin</em><sup><a href="#ref-wp-sameorigin">[5]</a></sup> правилото и политиките за сигурност на браузъра, в който се изпълнява.</p>
<h3 id="*webassembly*-е-отворен-и-подходящ-за-дебъгване"><a class="header-link" href="#*webassembly*-е-отворен-и-подходящ-за-дебъгване"></a><em>WebAssembly</em> е отворен и подходящ за дебъгване</h3>
<p><a name="features-open"></a></p>
<p><em>WebAssembly</em> е направен да може да се извежда (<em>pretty-print</em>) в текстов формат за по-лесно дебъгване, тестване, експериментиране, оптимизиране, научаване, обучение и писане на програми на ръка.  Този формат се използва при показването на изходния код на <em>wasm</em> модули в уеб браузъра.</p>
<p><a name="features-web"></a></p>
<h3 id="*webassembly*-е-част-от-общата-уеб-платформа"><a class="header-link" href="#*webassembly*-е-част-от-общата-уеб-платформа"></a><em>WebAssembly</em> е част от общата уеб платформа</h3>
<p><em>WebAssembly</em> е създаден със съображението, че в уеб пространството няма версии, но за сметка на това има обратна съвместимост.  <em>WebAssembly</em> модулите могат да достъпват функционалността на браузъра през същите програмни интерфейси, които са достъпни и през JavaScript.  Освен всичко това <em>WebAssembly</em> поддържа вграждане в софтуер, който не е предназначен за уеб.</p>
<p><a name="goals"></a></p>
<h2 id="цели-на-проекта-*webassembly*"><a class="header-link" href="#цели-на-проекта-*webassembly*"></a>Цели на проекта <em>WebAssembly</em></h2>
<ul class="list">
<li>Да дефинира бинарен формат за изпълними файлове, който е оптимизиран откъм размер и време за изпълнение.  Програмите, компилирани до него, трябва да достигат скорост на изпълнение, сходна с тази на софтуера, изпълняван директно върху реалния хардуер на машината.</li>
<li>Да специфицира и да имплементира един по един следните стадии на развитие:<ul class="list">
<li><em>минимален работещ продукт</em> (<em>minimum viable product</em><sup><a href="#ref-wp-mvp">[6]</a></sup>) с функционалност, сходна с тази на оптимизирания вариант на JavaScript <code>asm.js</code><sup><a href="#ref-wp-asmjs">[7]</a></sup>, която да таргетира основно езиците C и C++;</li>
<li>продукт с допълнителни характеристики, първоначално фокусирани върху ключови свойства за една виртуална машина, като например поддръжка за нишки, <em>zero-cost</em> изключения и SIMD инструкции, както и поддръжка за езици, различни от C и C++.</li>
</ul>
</li>
<li>Да може да се изпълнява в рамките на и да се интегрира с вече съществуващата уеб платформа:<ul class="list">
<li>да се съобразява с липсата на версии и силно изявената обратна съвместимост, утвърдили се като <em>де факто</em> стандарт при постепенното развитие на уеб технологиите;</li>
<li>да е съвместима със семантиката на езика за програмиране JavaScript;</li>
<li>да поддържа синхронни извиквания на JavaScript функции, както и да могат <em>WebAssembly</em> функции да бъдат извиквани от JavaScript;</li>
<li>да налага <em>same-origin</em> правилото като политика за сигурност в браузъра;</li>
<li>да достъпва функционалността на браузъра през същите уеб API-та, през които я достъпва и JavaScript;</li>
<li>да дефинира ръчно редактируем текстов формат, конвертируем към бинарния формат (който се използва по подразбиране), който може да се достъпи посредством <strong>View Source</strong> функционалността.</li>
</ul>
</li>
<li>Да поддържа вграждане в софтуер, който не е браузър.</li>
<li>Да бъде използваема и надеждна платформа чрез създаването на:<ul class="list">
<li><em>LLVM</em> бекенд за <em>WebAssembly</em> и, съответно, port-нат вариант на <em>clang</em> за този бекенд;</li>
<li>допълнителни компилатори и придружаващи ги инструменти, таргетиращи <em>WebAssembly</em>;</li>
<li>други полезни инструменти за <em>WebAssembly</em>.</li>
</ul>
</li>
</ul>
<p><a name="rationale"></a></p>
<h2 id="причини-за-създаване"><a class="header-link" href="#причини-за-създаване"></a>Причини за създаване</h2>
<p>При положение, че вече съществуват технологии като <code>asm.js</code>, както и имплементации на POSIX нишки (<em>pthreads</em>)<sup><a href="#ref-moz-paralleljs">[8]</a></sup><sup><a href="#ref-blinkdev-shbuf">[9]</a></sup> и SIMD инструкции<sup><a href="#ref-moz-simdjs">[10]</a></sup><sup><a href="#ref-blinkdev-simdjs">[11]</a></sup> във Firefox и Chromium, на пръв поглед разработването на <em>WebAssembly</em> изглежда лишено от смисъл.</p>
<p>Разбира се, на практика нещата са доста по-различни.  <em>WebAssembly</em> има две основни предимства, които гореспоменатите технологии не предоставят:</p>
<ol class="list">
<li>Бинарният формат, използван в <em>WebAssembly</em>, може да се декодира много по-бързо, отколкото JavaScript може се парсва (експерименталните данни показват над 20-кратно ускорение).  На мобилните платформи големи кодови бази могат да отнемат от 20 до 40 секунди <em>само</em> за парсване (дори и да са минифицирани), така че <em>native</em> декодирането (особено когато е комбинирано с други техники като stream-ове<sup><a href="#ref-w3c-streamsapi">[12]</a></sup> за постигане на по-добра компресия от <em>gzip</em>) е ключово за постигането на добър UX при студен старт.</li>
<li>Чрез избягването на ограничението за задължителна <em>ahead-of-time</em> компилация<sup><a href="#ref-asmjs-aot">[13]</a></sup> и постигането на добра производителност дори при енджини без специфични <code>asm.js</code> оптимизации<sup><a href="#ref-asmjs-opts">[14]</a></sup> може <a href="#future-features">имплементацията да се разшири</a> по подходящ начин, така че се достигат <em>native</em> нива на производителност.</li>
</ol>
<p>Естествено, всеки нов стандарт създава затруднения (трябва да се поддържа и обновява; може да бъде потенциална цел за хакерски атаки; размерът на кода трябва да се придържа в разумни граници), които могат евентуално да засенчат предимствата му.  <em>WebAssembly</em> се старае да направи затрудненията минимални, използвайки дизайн, който позволява на (но не задължава) всеки един браузър да го имплементира <em>вътре</em> в собствения си JavaScript енджин, преизползвайки по този начин вече съществуващия компилиращ бекенд на енджина, както и фронтенда за зареждане на <em>ECMAScript</em> 6 (ES6) модули, механизмите за изолация (<em>sandboxing</em>) на програмите и други допълнителни компоненти на виртуалната машина.  Затова от гледна точка на трудност и цена на имплементация <em>WebAssembly</em> трябва да се разглежда по-скоро като голям нов <em>feature</em> на JavaScript, отколкото като фундаментално разширение на модела на браузъра.</p>
<p>Ако сравняваме <em>WebAssembly</em> и <code>asm.js</code>, даже и при енджините, при които <code>asm.js</code> вече е оптимизиран, предимствата надхвърлят недостатъците и рисковете.</p>
<p><a name="semantics"></a></p>
<h2 id="семантика-на-изпълнението-на-байткода"><a class="header-link" href="#семантика-на-изпълнението-на-байткода"></a>Семантика на изпълнението на байткода</h2>
<p>Последващият раздел ще обясни дизайна на високо ниво на кода на <em>WebAssembly</em>, включително неговите типове, конструкции и семантика.  Кодът на <em>WebAssembly</em> може да се счита за <em>структурирана стекова машина</em>, т.е. виртуална машина, в която повечето изчисления използват стек от стойности, но императивните операции се представят чрез структурирани конструкции като блокове, <code>if</code> оператори и цикли.  На практика имплементациите не се нуждаят от буквален стек за стойности, нито пък реални структури от данни за контрол на изпълнението на програмата; те просто трябва да се <em>преструват</em>, че включват в себе си тези структури от данни.  Повече детайли могат да бъдат намерени във формалната спецификация на <em>WebAssembly</em><sup><a href="#ref-spec">[15]</a></sup>.</p>
<p>Всяко <em>тяло</em> на функция се състои от списък от инструкции, които формират имплицитен <em>блок</em>.  Изпълнението на инструкции се определя от <em>програмен брояч</em>, който се увеличава при преминаване на следваща инструкция.  Инструкциите биват две категории: <em>контролни</em>, които формират контролни конструкции, както и <em>прости</em>.  Контролните инструкции вадят аргументите си от върха на стека, могат при необходимост да променят програмния брояч, като накрая резултатн(а/и) стойност(и) на върха на стека.  Простите инструкции вадят аргументите от стека, прилагат им оператор, и след това слагат резултат(а/ите) обратно върху стека, което се следва от имлицитно увеличение на програмния брояч.</p>
<p>Всички инструкции и оператори в <em>WebAssembly</em> са експлицитно (<em>строго</em>) типизирани без изключения и имплицитни преобразования.  За да се верифицира <em>WebAssembly</em> код, е достатъчна само една проверка на типовете (която е с константа времева сложност), както и проверка за коректност на синтаксиса.</p>
<p>WebAssembly предлага набор от езиково независими оператори, които са близки до операторите в множество езици за програмиране и могат да се имплементират ефективно на всички модерни компютри.  За всеки оператор има съответна проста инструкция.</p>
<p><a name="semantics-traps"></a></p>
<h3 id="прекъсвания-(traps)"><a class="header-link" href="#прекъсвания-(traps)"></a>Прекъсвания (traps)</h3>
<p>Някои оператори могат да прекъснат, както е отбелязано по-долу.  В примерната имплементация (<em>MVP</em>) <em>trap</em> означава, че изпълнението на инстанцията на <em>WebAssembly</em> се спира и на външната среда се съобщава за извънредно прекъсване на изпълнението (<em>abnormal termination</em>).  В JavaScript среда (като браузър, например) <em>trap</em> означава хвърляне на JavaScript изключение.  Ако са включени инструменти за разработчици, може да се прикачи дебъгер преди прекъсването за откриване на причината за него.</p>
<p><a name="semantics-stackoverflow"></a></p>
<h3 id="нахдърляне-на-размера-на-стека-(*stack-overflow*)"><a class="header-link" href="#нахдърляне-на-размера-на-стека-(*stack-overflow*)"></a>Нахдърляне на размера на стека (<em>stack overflow</em>)</h3>
<p>Размерът (т.е. капацитетът) на стека с извикванията е ограничен, като стойността му не е фиксирана при компилация, и може да бъде определена само по време на изпълнение.  Ако употребата му надвиши капацитета му, изпълнението на текущата <em>WebAssembly</em> инстанция се спира и на външната среда се съобщава за извънредно прекъсване на изпълнението (<em>abnormal termination</em>).</p>
<p>Имплементациите трябва да имат вътрешен максимален размер на стека с извикванията.  Това правило е въведено с цел избягване на разликите в наблюдаваното поведение:  ако някои имплементации имат въпросното свойство, а други го нямат, една и съща програма, изпълнена на една имплементация, може да заеме неопределено количество ресурси, а на друга да прекъсне изпълнението си.  Освен това се очаква, че в бъдеще WebAssembly юе придобие механизъм за наблюдение на съдържанието на стека, чрез който такива оптимизации ще са директно видими.</p>
<p>В бъдеще се планира добавянето на експлицитни <em>опашкови извиквания</em>, което ще включва експлицитен оператор за целта с добре дефинирани ефекти върху наблюдение на стека.</p>
<p><a name="semantics-types"></a></p>
<h3 id="типове"><a class="header-link" href="#типове"></a>Типове</h3>
<p>В WebAssembly има следните <em>типове, предавани по стойност</em>:</p>
<ul class="list">
<li><code>i32</code> - 32-битово цяло число</li>
<li><code>i64</code> - 64-битово цяло число</li>
<li><code>f32</code> - 32-битово число с плаваща запетая</li>
<li><code>f64</code> - 64-битово число с плаваща запетая</li>
</ul>
<p>Всеки параметър и всяка локална променлива имат точно един тип, предаван по стойност.  Сигнатурите на функции имат нула или повече типове на параметрите и последователност от нула или повече типове на връщане.  (<em>Забележка:</em>  В примерната имплементация функциите могат да имат само един тип на връщане.)</p>
<p>Типовете <code>i32</code> и <code>i64</code> не са със или без знак сами по себе си; интерпретацията им като такива се определя от операторите.</p>
<p><a name="semantics-linearmemory"></a></p>
<h3 id="линейна-памет"><a class="header-link" href="#линейна-памет"></a>Линейна памет</h3>
<p><em>Линейната памет</em> е продължителна зона в паметта, адресируема по байтове, обхващаща от позиция <code>0</code>, и достигаща до неопределен <em>размер на паметта</em>.  Той винаги е кратен на размера на страницата в <em>WebAssembly</em>, който е фиксиран на 64 KiB (макар че в бъдещи версии на спецификацията се очаква да бъде добавена поддръжка за големи страници).  Началното състояние на линейната памет се дефинира от секциите за <em>линейна памет</em> и <em>данни</em> на модула.  Размерът на паметта може да се увеличава посредством <code>grow_memory</code> оператора.</p>
<p>Линейната памет може да се счита за безтипов масив от байтове, като в спецификацията не е определен начинът, по който тази памет се съпоставя с виртуалната памет, заделена за процеса, изпълняващ инстанцията на <em>WebAssembly</em>.  Линейната памет е изолирана (<em>sandboxed</em>):  тя не се припокрива (<em>alias</em>-ва) с други видове памет, както и с вътрешните структури от данни на имплементацията, стека с извиквания, локалните променливи, или паметта на други процеси.</p>
<p>Всяка инстанция на <em>WebAssembly</em> има една специфично определена като линейна памет <em>по подразбиране</em>, която се достъпва от долупосочените <em>оператори за достъп до паметта</em>.  В примерната имплементация има само оператори за работа с паметта по подразбиране, като впоследствие може да бъдат добавени <em>оператори за заделяне и достъп до нова памет</em>.</p>
<p>Линейната памет може да се <em>внесе</em> (<em>import</em>-не) или <em>дефинира</em> вътре в модула.  След внасяне или дефиниция няма никаква разлика между това дали се достъпва внесена или вътрешно дефинирана памет.</p>
<p>В примерната имплементация линейната памет не може да се споделя между нишки (които все още предстои да бъдат добавени).</p>
<p><a name="semantics-linearmemoryops"></a></p>
<h3 id="оператори-за-достъп-до-линейната-памет"><a class="header-link" href="#оператори-за-достъп-до-линейната-памет"></a>Оператори за достъп до линейната памет</h3>
<p>Достъпът до линейната памет се осъществява посредством експлицитни <code>load</code> (за <em>зареждане</em>) и <code>store</code> (за <em>съхранение</em>) оператори.  Всички те ползват <em>little-endian</em> подредба на байтовете (както в <em>x86</em> архитектурата) при преобразуването между стойности и байтове.  При зареждане на цели числа може да се определи <em>размер за съхранение</em>, който да е по-малък от размера на резултантния тип, както и <em>знаковост</em> (наличие на знак минус за числото), която определя дали да се заделя бит за знак при разширяването на типа:</p>
<ul class="list">
<li><code>i32.load8_s</code>: зареди 1 байт и го разшири от i8 до i32, съобразявайки се с наличието на знак</li>
<li><code>i32.load8_u</code>: зареди 1 байт и го разшири от i8 до i32</li>
<li><code>i32.load16_s</code>: зареди 2 байта и ги разшири от i16 до i32, съобразявайки се с наличието на знак</li>
<li><code>i32.load16_u</code>: зареди 2 байта и ги разшири от i16 до i32</li>
<li><code>i32.load</code>: зареди 4 байта as i32</li>
<li><code>i64.load8_s</code>: зареди 1 байт и го разшири от i8 до i64, съобразявайки се с наличието на знак</li>
<li><code>i64.load8_u</code>: зареди 1 байт и го разшири от i8 до i64</li>
<li><code>i64.load16_s</code>: зареди 2 байта и ги разшири от i16 до i64, съобразявайки се с наличието на знак</li>
<li><code>i64.load16_u</code>: зареди 2 байта и ги разшири от i16 до i64</li>
<li><code>i64.load32_s</code>: зареди 4 байта и ги разшири от i32 до i64, съобразявайки се с наличието на знак</li>
<li><code>i64.load32_u</code>: зареди 4 байта и ги разшири от i32 до i64</li>
<li><code>i64.load</code>: зареди 8 байта като i64</li>
<li><code>f32.load</code>: зареди 4 байта като f32</li>
<li><code>f64.load</code>: зареди 8 байта като f64</li>
</ul>
<p><code>store</code> операциите имат допълнителен операнд, който представлява стойността за съхранение в паметта.  Както при <code>load</code>-овете, при <code>store</code>-ване на цели числа може да се определи по-малък размер за съхранение от размера на операнда, като в този случай се подразбира закръгляне:</p>
<ul class="list">
<li><code>i32.store8</code>: смали i32 до i8 и съхрани 1 байт</li>
<li><code>i32.store16</code>: смали i32 до i16 и съхрани 2 байта</li>
<li><code>i32.store</code>: (без конверсия) съхрани 4 байта</li>
<li><code>i64.store8</code>: смали i64 до i8 и съхрани 1 байт</li>
<li><code>i64.store16</code>: смали i64 до i16 и съхрани 2 байта</li>
<li><code>i64.store32</code>: смали i64 до i32 и съхрани 4 байта</li>
<li><code>i64.store</code>: (без конверсия) съхрани 8 байта</li>
<li><code>f32.store</code>: (без конверсия) съхрани 4 байта</li>
<li><code>f64.store</code>: (без конверсия) съхрани 8 байта</li>
</ul>
<p>Операторите за съхранение не връщат стойност.
Горепосочените оператори работят с линейната памет по подразбиране.</p>
<p><a name="semantics-addressing"></a></p>
<h3 id="адресиране"><a class="header-link" href="#адресиране"></a>Адресиране</h3>
<p>Всеки оператор за достъп до линейната памет има операнд за адрес и байтов офсет, който представлява цяло число без знак.  Сумата без знак на адреса и офсета се нарича <em>ефективен (реален) адрес</em>, който се интерпретира като беззнаков индекс на байт във виртуалната памет.</p>
<p>Операторите за достъп до линейната памет достъпват байтовете, започвайки от ефективния адрес, и продължавайки със съответния брой байтове, определен от размера на съхранение.  Ако някой от достъпваните байтове се намира след текущия размер на паметта, достъпът се окачествява като <em>извънграничен</em> (<em>out-of-bounds</em>).</p>
<p>Използването на неограничена прецизност при изчислението на ефективните адреси означава, че прибавянето на офсета към адреса никога не <em>превърта</em> (<em>wrap</em>-ва), така че ако адресът за даден достъп е извънграничен, то ефективният адрес също ще е такъв.</p>
<p>В <em>wasm32</em> адресът и офсетът са от тип <code>i32</code> и линейната памет е ограничена до 4 GiB (разбира се, реалните размери са допълнително ограничени от наличните ресурси).  В <em>wasm64</em> операндите на адресите и офсетите са от тип <code>i64</code>.  Примерната имплементация включва само <code>wasm32</code>, като в последващите версии ще бъде добавена поддръжка за <code>wasm64</code> и съответно за линейна памет с размер повече от 4 GiB.</p>
<p><a name="semantics-alignment"></a></p>
<h3 id="подравняване-(*alignment*)"><a class="header-link" href="#подравняване-(*alignment*)"></a>Подравняване (<em>alignment</em>)</h3>
<p>Всеки оператор за линеен достъп до паметта има за атрибут число - положителна целочислена степен на двойката, което се използва за подравняване на адреса, като то не трябва да е по-голямо от размера на достъпа до паметта.  Подравняване, което е същото като размера на достъп, се счита за естественото подравняване.  То се прилага към ефективния адрес (не просто към адреса), т.е. офсетът се взима предвид при евентуално подравняване.</p>
<p>Подравняването има същия тип (който се определя от <em>wasm32</em> или от <em>wasm64</em>, както е описано по-горе) както адреса и офсета.</p>
<p>Ако ефективният адрес на достъп е степен на стойността за подравняване, достъпът до паметта се счита за <em>подравнен</em>; в противен слуачй той е <em>неподравнен</em>.  Подравнените и неподравнените достъп имат едно и също поведение.</p>
<p>Подравняването афектира изпълнението както следва:</p>
<ul class="list">
<li>Подравнените достъпи с поне естествено подравнение са бързи.</li>
<li>Подравнените достъпи с по-малко от естественото подравнение са малко по-бавни (защото имплементацията извършва множество достъпи в софтуера или в хардуера).</li>
<li>Неподравнените достъпи от какъвто и да е вид са <em>много</em> по-бавни (те трябва да се подравняват собственоръчно от имплементацията).</li>
</ul>
<p>Затова се препоръчва при имплементация на <em>WebAssembly</em> да се подравняват често използваните данни с цел позволяване на естествено подравняване при достъп.  При зареждания и съхранения трябва да се ползват възможно най-големите стойности за подравняване, както и да се избягват неподравнените достъпи.</p>
<p><a name="semantics-oob"></a></p>
<h3 id="*out-of-bounds*-достъп-до-памет"><a class="header-link" href="#*out-of-bounds*-достъп-до-памет"></a><em>Out-of-bounds</em> достъп до памет</h3>
<p>При <em>out-of-bounds</em> достъпване на памет се генерира <a href="#semantics-traps">прекъсване</a>.</p>
<p><a name="semantics-resizing"></a></p>
<h3 id="преоразмеряване"><a class="header-link" href="#преоразмеряване"></a>Преоразмеряване</h3>
<p>В примерната имплементация линейната памет може да се преоразмери чрез <code>grow_memory</code> оператор.  На него се подава като операнд брой страници (които, както споменахме по-горе, са с фиксиран размер 64 KiB).</p>
<ul class="list">
<li><code>grow_memory</code>: увеличава линейната памет с дадения брой страници (цяло число без знак).  Връща предишният размер на паметта в брой страници или <code>-1</code> при провал.</li>
</ul>
<p>Когато линейната памет достигне максималния си размер, <code>grow_memory</code> трябва да приключи неуспешно, ако ще се увеличава след максимума.  Все пак извикването може да <em>fail</em>-не и преди достигане на максимума, ако не е било възможно да се запази мястото, или ако разрешаването на достъпа до запазената памет не успее.  Ако няма дефиниран максимален размер, се очаква <code>grow_memory</code> да извърши системна алокация, която също може да не успее.</p>
<p>Текущият размер на линейната памет може да бъде взет чрез изпълнението на следния оператор:</p>
<ul class="list">
<li><code>current_memory</code>: връща текущият размер на паметта в брой страници.</li>
</ul>
<p>Както е споменато <a href="#semantics-linearmemory">по-горе</a>, линейната памет е непрекъсната, което означава, че няма &quot;<em>дупки</em>&quot; в линейното адресно пространство.  Има предложения за включване на механизми за контрол на паметта в бъдещи версии на примерната имплементация с цел позволяване на защита на алокираните сегменти и съпоставянето на линейната памет към последователна виртуална памет.</p>
<p>В примерната имплементация паметта може само да бъде увеличавана.  Предвижда се добавянето на оператор за намаляване на паметта.  Все пак, поради получаващата се фрагментация, се очаква приложенията да освобождават неизползваните физически страници, използвайки бъдещото свойство <code>discard</code>.</p>
<p>Горепосочените оператори работят с линейната памет по подразбиране.</p>
<p><a name="binaryencoding"></a></p>
<h2 id="бинарен-формат-за-изпълнимите-файлове"><a class="header-link" href="#бинарен-формат-за-изпълнимите-файлове"></a>Бинарен формат за изпълнимите файлове</h2>
<p>Този раздел описва <a href="#portability">преносимия</a> бинарен формат на изпълнимите файлове на <em>WebAssembly</em> модулите.</p>
<p>Двоичното кодиране е сбито представяне на информацията за модула, което води до по-малки файлове, бързо декодиране, и намалено използване на памет.  Повече информация може да се намери в раздела с <a href="#rationale">причините за създаване</a>.</p>
<p>Кодирането е разделено на три слоя:</p>
<ul class="list">
<li><strong>Слой 0</strong> представлява просто бинарно кодиране на инструкциите в байткода и свързаните с тях структури от данни.  То е сбито и тривиално за интеракция, което го прави подходящо за сценарии като <em>just-in-time</em> компилация, инструментиране и дебъгване.</li>
<li><strong>Слой 1</strong> добавя структурна компресия към <strong>слой 0</strong>, възползвайки се от избраното представяне на синтактичното дърво и клоните му.  Тази компресия позволява по-ефективно кодиране на стойностите, пренарежда стойностите вътре в модула, и премахва (<em>отрязва</em>) клоните на дървото, които са еднакви като структура.</li>
<li><strong>Слой 2</strong> прилага алгоритми за компресия от общ вид като <a href="http://www.gzip.org/">gzip</a> и <a href="https://datatracker.ietf.org/doc/draft-alakuijala-brotli/">Brotli</a>, които вече съществуват в уеб браузърите и придружаващите ги инструменти.</li>
</ul>
<p>Най-важната особеност на този слоест подход е, че позволява разработката и стандартизацията да се случват последователно.  Например може да се експериментира с техниките за кодиране при <strong>Layer 1</strong> и <strong>Layer 2</strong> чрез декомпресиране до по-долния слой.  При стабилизация на техниките за компресия, те могат да бъдат стандартизирани и включени в <em>native</em> имплементации.</p>
<p>Има предложен (но не имплементиран) алгоритъм за структурна компресия в примерната имплементация.</p>
<p><a name="binaryencoding-datatypes"></a></p>
<h3 id="типове-данни"><a class="header-link" href="#типове-данни"></a>Типове данни</h3>
<p>Повече информация може да бъде намерена в документацията на дизайна на <em>WebAssembly</em><sup><a href="#ref-design-datatypes">[16]</a></sup>.</p>
<p><a name="binaryencoding-modulestructure"></a></p>
<h3 id="структура-на-модулите"><a class="header-link" href="#структура-на-модулите"></a>Структура на модулите</h3>
<p>Повече информация може да бъде намерена в документацията на дизайна на <em>WebAssembly</em><sup><a href="#ref-design-modulestructure">[17]</a></sup>.</p>
<p><a name="binaryencoding-functionbodies"></a></p>
<h3 id="тела-на-функции"><a class="header-link" href="#тела-на-функции"></a>Тела на функции</h3>
<p>Повече информация може да бъде намерена в документацията на дизайна на <em>WebAssembly</em><sup><a href="#ref-design-functionbodies">[18]</a></sup>.</p>
<p><a name="textformat"></a></p>
<h2 id="редактируем-текстов-формат"><a class="header-link" href="#редактируем-текстов-формат"></a>Редактируем текстов формат</h2>
<p>В <em>WebAssembly</em> все още няма стандартизиран текстов формат, който да кодира телата на функциите в допълнение към структурата на модулите, сегментите с данни, и други програмни метаданни по начин, еквивалентен на <a href="#binaryencoding">бинарния формат</a>.  В <em>WebAssembly</em> обаче има <a href="#textformat-bytecode">текстово представяне</a> на телата на функциите, което може да бъде показано в браузърите и в други инструменти при дебъгване на модули.</p>
<p><a name="textformat-bytecode"></a></p>
<h3 id="линеен-байткод"><a class="header-link" href="#линеен-байткод"></a>Линеен байткод</h3>
<p>В <em>WebAssembly</em> телата на функциите са съставени от байткод инструкции със специфични канонични имена на <em>opcode</em>-ове.  Линейното представяне на тези поредици от инструкции позволява представянето на бинарния формат в четим от човек вид, който запазва последователността на инструкциите.  Този формат е подходящ за изследването на <em>WebAssembly</em> програма инструкция по инструкция, и е пряко свързан със <a href="#semantics">семантичните особености</a> на бинарния формат.</p>
<p>Следва примерна функция, представена като C++ код, в бинарния и в текстовия формат (<em>асемблерен език за линеен байткод</em>):</p>
<table>
  <tr>
    <th>C++</th>
    <th>Бинарен формат</th>
    <th>Текстов формат</th>
  </tr>
  <tr>
    <td><pre>
int factorial(int n) {
  if (n == 0)
    return 1;
  else
    return n * fac(n-1);
}</pre></td>
    <td><pre>
20 00
42 00
51
04 7e
42 01
05
20 00
20 00
42 01
7d
10 00
7e
0b</pre></td>
    <td><pre>
get_local 0
i64.const 0
i64.eq
if i64
    i64.const 1
else
    get_local 0
    get_local 0
    i64.const 1
    i64.sub
    call 0
    i64.mul
end</pre></td>
  </tr>
</table>

<p><a name="textformat-tools"></a></p>
<h3 id="конвенции-за-инструменти-за-работа-с-байткода"><a class="header-link" href="#конвенции-за-инструменти-за-работа-с-байткода"></a>Конвенции за инструменти за работа с байткода</h3>
<p>Повечето <em>WebAssembly</em> инструменти в момента използват <em>s-изрази</em><sup><a href="#ref-wp-sexpr">[19]</a></sup>, за да представят модулите в текстов формат.  Въпреки че този формат не е официален текстов формат, той е де факто стандарт за инструменти, тъй като позволява представянето на сигнатури на функции, декларации и други метаданни.</p>
<p>Ето някои примерни прототипи (никой от тях не е официален):</p>
<ul class="list">
<li><a href="https://github.com/WebAssembly/spec/tree/master/interpreter/test">prototype specification</a></li>
<li><a href="https://github.com/llvm-mirror/llvm/tree/master/test/CodeGen/WebAssembly">LLVM backend</a></li>
<li><a href="https://github.com/AndrewScheidecker/WAVM/tree/master/Test">WAVM backend</a></li>
<li><a href="https://github.com/WebAssembly/v8-native-prototype">V8 prototype</a></li>
<li><a href="https://github.com/WebAssembly/ilwasm">ilwasm</a></li>
<li><a href="https://github.com/WebAssembly/wabt">wabt</a></li>
<li><a href="https://github.com/WebAssembly/binaryen">binaryen</a></li>
</ul>
<p><a name="textformat-debugging"></a></p>
<h3 id="интеграция-със-символи-за-дебъгване"><a class="header-link" href="#интеграция-със-символи-за-дебъгване"></a>Интеграция със символи за дебъгване</h3>
<p>Бинарният формат премахва имената от функции, локални и глобални променливи, редуцирайки ги до прости индекси.  Затова, при липса на подходящите инструменти, текстовият формат трябва сам да ги именова.  Тук на помощ идва глобалната секция за <em>символи за дебъгване</em> (която не е задължителна), която асоциира имена със всеки индексиран запис.  Ако тези имена съществуват при иницииране на дебъгване, те ще бъдат използвани в текстовия формат, който се генерира от бинарен <em>WebAssembly</em> модул.</p>
<p><a name="textformat-additional"></a></p>
<h3 id="допълнителни-съображения"><a class="header-link" href="#допълнителни-съображения"></a>Допълнителни съображения</h3>
<p>Няма дефинирано изискване да се използва синтаксиса на JavaScript, тъй като този формат не е предназначен да се превежда директно към JavaScript.  Може да има основателни причини да се използва <em>различен</em> от него синтаксис (например в <em>WebAssembly</em> има 64-битов целочислен тип, който трябва да може да се представи в текстовия формат по някакъв начин, въпреки че в JavaScript няма такъв тип).  От друга страна, ако няма такава причина, текстовият формат може да бъде съобразен с действащите конвенции в уеб (като например къдрави скоби, както в JavaScript и CSS).</p>
<p>Текстовият формат може да не е с недвусмислено представяне.  Множество различни текстови формати може в крайна сметка да се асемблират до един и същ бинарен файл.  Например празното пространство не трябва да има значение и инициализацията на паметта трябва да може да се разбие на по-малки части в текстовия формат.</p>
<p>Teкстовият формат трябва да се съобразява с това, че стойности, които не могат да се представят точно в бинарния формат, са невалидни и в текстовия.  Затова числата с плаваща запетая трябва да се представят като шестнайсетични стойности (т.е. по същия начин, както се представят в C99 и C++17, и както е специфицирано в IEEE-754-2008, раздел 5.12.3.)  Текстовият формат може да бъде подобрен, така че да поддържа повече четими от човек представяния, но без да има загуба на точност в представянето.</p>
<p><a name="portability"></a></p>
<h2 id="преносимост"><a class="header-link" href="#преносимост"></a>Преносимост</h2>
<p><a href="#binaryencoding">Бинарният формат</a> на <em>WebAssembly</em> е проектиран по такъв начин, че да може да се изпълнява на множество различни операционни системи и хардуерни архитекури, както <a href="#web">в уеб</a>, така и <a href="#not-web">извън него</a>.</p>
<p><a name="portability-efficiency"></a></p>
<h3 id="мерки-за-ефикасно-изпълнение"><a class="header-link" href="#мерки-за-ефикасно-изпълнение"></a>Мерки за ефикасно изпълнение</h3>
<p>Средите за изпълнение (т.е. върху които се изпълняват имплементациите), които не предлагат долуописаните характеристики, все пак може да могат да изпълняват <em>WebAssembly</em> модули въпреки това.  В някои случаи може да им се наложи да симулират поведение, което целевият хардуер или целевата операционна система не предлагат, преструвайки се, че то се поддържа.  Това понякога може да доведе до лоша провизводителност.</p>
<p>При стандартизацията на <em>WebAssembly</em> се очаква тези изисквания да се формализират.</p>
<p><em>WebAssembly</em> очаква средите за изпълнение да притежават следните характеристики:</p>
<ul class="list">
<li>8-битови байтове.</li>
<li>Адресируемост с гранулярност един байт.</li>
<li>Поддръжка за неподравнени достъпи до паметта или софтуерна емулация на такива.</li>
<li>Цели числа със знак в представяне <em>two&#39;s complement</em><sup><a href="#ref-wp-twoscompl">[20]</a></sup> (32-битови, по възможност и 64-битови).</li>
<li>32-битови и 64-битови числа с плаваща запетая.</li>
<li><em>Little-endian</em> подредба на байтовете.</li>
<li>Региони памет, които могат ефикасно да се адресират от 32-битови указатели или индекси.</li>
<li><em>wasm64</em> поддържа линейна памет, по-голяма от 4 GiB, използвайки 64-битови указатели или индекси.</li>
<li>Да е осигурена изолация между <em>WebAssembly</em> модулите и други модули или процеси, изпълняващи се върху същата машина.</li>
<li>Среда за изпълнение, която дава гаранция, че всички активни (т.е. неблокирани) нишки извършват дейност (дори и да няма същински паралелизъм при изпълнение).</li>
<li>Наличност на неблокиращи атомарни операции с паметта (при наличие на подравненост) за 8-, 16- и 32-битов достъп.  Като минимум трябва да е наличен оператор за сравнение и подмяна (<em>compare-and-exchange</em>) или негов еквивалент.</li>
<li><em>wasm64</em> изисква неблокиращи атомарни операции и за 64-битов достъп.</li>
</ul>
<p><a name="portability-api"></a></p>
<h3 id="api"><a class="header-link" href="#api"></a>API</h3>
<p><em>WebAssembly</em> не включва в себе си какъвто и да е програмен интерфейс или системни извиквания (<em>syscalls</em>), само механизъм за включване (<em>import</em>) на модули, който се дефинира от хост средата.  В уеб среда функционалността се достъпва чрез уеб API-тата, дефинирани от Отворената уеб платформа<sup><a href="#ref-wp-owp">[21]</a></sup>.  Разработчиците, таргетиращи <a href="#nonweb">среди, различни от уеб</a>, могат да избират между стандартните уеб API-та, стандартни не-уеб API-та (например POSIX<sup><a href="#ref-wp-posix">[22]</a></sup>), или да измислят свои собствени интерфейси.</p>
<p><a name="portability-source"></a></p>
<h3 id="преносимост-на-ниво-изходен-код"><a class="header-link" href="#преносимост-на-ниво-изходен-код"></a>Преносимост на ниво изходен код</h3>
<p>Преносимост на ниво изходен C или C++ код може да се постигне, като се програмира по зададено стандартно API (като POSIX) и като се разчита на компилатора и/или библиотеките да използват стандартен интерфейс към останалите <em>import</em>-и или по време на компилация (чрез <code>#ifdef</code>) или по време на изпълнение (чрез откриване на характеристики и динамично зареждане/свързване).</p>
<p><a name="security"></a></p>
<h2 id="сигурност"><a class="header-link" href="#сигурност"></a>Сигурност</h2>
<p>Моделът за сигурност на WebAssembly има две важни цели:</p>
<ol class="list">
<li>да защити потребителите от бъгави или зловредни модули;</li>
<li>да даде на разработчиците полезни примитиви и превантивни мерки за писане на сигурни приложения с ограниченията, зададени в <em>1.</em></li>
</ol>
<p><a name="security-users"></a></p>
<h3 id="потребители"><a class="header-link" href="#потребители"></a>Потребители</h3>
<p>Всеки <em>WebAssembly</em> модул се изпълнява в защитена (<em>sandboxed</em>) среда, отделена от средата на хоста посредством техники за изолиране на авариите (<em>fault isolation</em>).  Това означава, че:</p>
<ul class="list">
<li>приложенията се изпълняват независимо едно от друго и не могат да напуснат изолираната среда без подходящи за целта API-та;</li>
<li>приложенията се изпълняват детерминистично, с някои изключения.</li>
</ul>
<p>Освен това всеки модул подлежи на прилагане на някои политики за сигурност при вграждането му.  В контекста на <a href="#web">уеб браузър</a> това включва ограничения на потока на информация посредством <em>same-origin</em><sup><a href="#ref-w3c-sop">[23]</a></sup> правилото.  На платформа, <a href="#nonweb">различна от уеб</a>, това може да включва модела за сигурност на POSIX.</p>
<p><a name="security-developers"></a></p>
<h3 id="разработчици"><a class="header-link" href="#разработчици"></a>Разработчици</h3>
<p>Дизайнът на <em>WebAssembly</em> промотира писането на безопасни програми, елиминирайки опасни характеристики от семантиката на изпълнение, и същевременно запазвайки съвместимост с програмите, писани на C или C++.</p>
<p>Модулите трябва да декларират всички достъпни функции и свързаните им типове по време на зареждане, дори когато се използва динамично свързване.  Това позволява имплицитно прилагане на <em>control-flow integrity</em><sup><a href="#ref-cfi">[24]</a></sup> чрез добро структуриране на последователността на изпълнение (<em>control flow</em>).  Тъй като компилираният код е непроменяем (<em>immutable</em>) и не може да се наблюдава по време на изпълнение, <em>WebAssembly</em> програмите са защитени от атаки, свързани с прихващане на последователността на изпълнение (<em>control flow hijacking</em>).</p>
<ul class="list">
<li>Извикванията на функции трябва да определят индекса на цел, която има съответен валиден запис в индексното пространство на функциите или в индексното пространство на таблиците.</li>
<li>Непреките извиквания на функции трябва да бъдат подлагани на проверка на сигнатурите на типовете по време на изпълнение; сигнатурата на избраната непряка функция трябва да отговаря на сигнатурата, определена на мястото на извикване.</li>
<li>Използва се скрит стек за осигуряването на надежден стек на извикванията, който не подлежи на <em>buffer overflow</em> атаки в хийпа на модула, подсигурявайки по този начин безопасни връщания от функции.</li>
<li>Разклоненията (<em>branches</em>) трябва да сочат към валидни дестинации в обграждащата функция.</li>
</ul>
<p>Променливите в C и C++ могат да се сведат до две различни примитиви в <em>WebAssembly</em> в зависимост от обхвата (<em>scope</em>-а) им.  Локалните променливи с фиксиран обхват, както и глобалните, се представят като стойности с фиксиран тип, съхранявани по индекс.  Първите се инициализират до нула по подразбиране и се съхраняват в защитения скрит стек, а вторите се намират в глобалното пространство от индекси, и могат да бъдат внасяни от външни модули.  Локалните променливи с неясен статичен обхват (например ако се използват от оператора за адресиране, или ако са от тип <code>struct</code> и са върнати по стойност) се съхраняват по време на компилация в отделен стек в <a href="#semantics-linearmemory">линейната памет</a>, адресируем от потребителя.  Това е изолиран регион в паметта с фиксиран максимален размер, който се инициализира с нули по подразбиране.  Референциите към тази памет се изчисляват с неограничена прецизност с цел избягване на превъртането (<em>wrapping</em>) и опростяване на проверката за ограничения (<em>bounds-checking</em>).  В бъдеще ще се поддържат множество раздели с линейна памет, както и по-прецизни операции с нея (т.е. споделена памет, защита на страници, големи страници).</p>
<p>Прекъсванията (<em>traps</em>) се използват за незабавно приключване на изпълнението и съобщаване за нередно поведение на средата за изпълнение.  В браузъра това се предствавя чрез JavaScript изключение.  В бъдеще ще бъде добавена поддръжка за прихващачи на прекъсвания (<em>trap handlers</em>).  За момента операциите, които извършат прекъсване, са:</p>
<ul class="list">
<li>определянето на невалиден индекс в което и да е индексно пространство;</li>
<li>изпълняването на непряко извикване на функция с несъответстваща сигнатура;</li>
<li>надхвърлянето на максималния размер на стека за защитени извиквания;</li>
<li>достъпването на <em>out-of-bounds</em> адреси в линейната памет;</li>
<li>изпълняването на неправилни аритметични операции (например делене или взимане на остатък при делене на нула, <em>overflow</em> при делене на цели числа със знак и т.н.)</li>
</ul>
<p><a name="security-memsafety"></a></p>
<h3 id="безопасност-на-паметта"><a class="header-link" href="#безопасност-на-паметта"></a>Безопасност на паметта</h3>
<p>В сравнение със C и C++, горепосочената семантика отстранява определени класове от бъгове, свързани с безопасността на достъпа до паметта.  <em>Buffer overlow</em>-ите, които се случват при преминаване на границите в паметта на даден обект и достъпването на съседни региони памет, не могат да афектират глобалните или локалните променливи, съхранени в пространството от индекси: те са с фиксиран размер и се адресират по индекс.  Данните, съхранявани в линейната памет, могат да презапишат съседни обекти, тъй като проверката за ограничения се изпълнява с гранулярност регион в линейната памет и не е чувствителна към контекста (<em>context-sensitive</em>).  Разбира се, наличието на <em>control-flow integrity</em> и защитеност на скритите стекове предотвратява атаките, включващи пряко вкарване (<em>injection</em>) на код.  Вследствие от това превантивни мерки (<em>mitigations</em>) като <em>data execution prevention</em> (<em>DEP</em>)<sup><a href="#ref-wp-execprot">[25]</a></sup> или пък <em>stack smashing protection</em> (<em>SSP</em>)<sup><a href="#ref-wp-randcanaries">[26]</a></sup> не са необходими при <em>WebAssembly</em> програми.</p>
<p>Друг голям клас от грешки, свързани с безопасността на паметта, са грешките при неправилна употреба на указатели, както и неопределените поведения.  Те включват дереферирането на указатели към незаделена памет (например <code>NULL</code>) и алокациите на освободена памет.  В <em>WebAssembly</em> семантиката на указателите не съществува при извикванията на функции и променливи с фиксиран статичен обхват, позволявайки референции към невалидни индекси в което и да е пространство от индекси да предизвикат грешки при валидация по време на зареждане, или в най-лошия случай прекъсване по време на изпълнение.  Тези региони са изолирани от вътрешната памет на <em>runtime</em>-а, и по подразбиране се инициализират с нули (ако все още не са инициализирани).</p>
<p>И все пак съществуват бъгове, които не се влияят от семантиката на <em>WebAssembly</em>.  Въпреки че атакуващите една <em>WebAssembly</em> инстанция не могат да изпълняват директни атаки, включващи инжектиране на код, има възможност да се прихване (<em>hijack</em>-не) последователността на изпълнение на модул чрез атаки, базирани на преизползването на код, срещу непреки извиквания.  За сметка на това конвенционалните <em>return-oriented programming</em> (ROP)<sup><a href="#ref-wp-rop">[27]</a></sup> атаки, използващи кратки последователности от инструкциите (<em>gadget</em>-и), не са възможни в <em>WebAssembly</em>, тъй като <em>control-flow integrity</em>-то дава гаранция, че всички извиквани функции са валидни и декларирани по време на зареждане на модула.  По същата логика състезанията (<em>race conditions</em>), като например <em>time of check to time of use</em> (<em>TOCTOU</em>)<sup><a href="#ref-wp-toctou">[28]</a></sup> уязвимости, са възможни в <em>WebAssembly</em>, тъй като няма други гаранции за последователността на изпълнението и разпределението на задачите освен <em>in-order</em> изпълнение и <em>атомарни примитиви за достъп до паметта</em>.  По същия начин могат да бъдат извършени <em>side-channel</em> атаки<sup><a href="#ref-wp-sidechan">[29]</a></sup>, като например <em>timing</em> атаки срещу модули.  В бъдеще ще бъдат имплементирани допълнителни защити в <em>runtime</em>-а и <em>toolchain</em>-а, като някои от тях са диверсификация на кода и рандомизация на паметта (подобна на рандомизацията на адресното пространство<sup><a href="#ref-wp-aslr">[30]</a></sup>), ограничени (т.нар. &quot;<em>дебели</em>&quot;) указатели<sup><a href="#ref-wp-boundedptr">[31]</a></sup> и по-голяма прецизност на <em>control-flow integrity</em>.</p>
<p><a name="web"></a></p>
<h2 id="употреба-за-уеб-базирани-приложения"><a class="header-link" href="#употреба-за-уеб-базирани-приложения"></a>Употреба за уеб-базирани приложения</h2>
<p>Очевидно едно от основните предназначения на <em>WebAssembly</em> е да се изпълнява в уеб, например във вградени браузъри (разбира се, това <a href="#nonweb">не е единственото му предназначение</a>).</p>
<p>Това означава интеграция с уеб екосистемата, използване на уеб API-та, поддържане на модела за сигурност на уеб и запазване на преносимостта на уеб.  Много от тези цели са <a href="#goals">споменати по-горе</a>.  В частност примерната имплементация на <em>WebAssembly</em> няма как да стане по-несигурна, ако се използва модул за JavaScript.</p>
<p>Следва списък от връзки между <em>WebAssembly</em> и останалата част от уеб платформата:</p>
<p><a name="web-jsapi"></a></p>
<h3 id="javascript-api"><a class="header-link" href="#javascript-api"></a>JavaScript API</h3>
<p>Има JavaScript API, което позволява компилация на JavaScript до <em>WebAssembly</em> модули; изпълнява ограничен <em>reflection</em> върху компилираните модули; съхранява и зарежда компилирани модули от офлайн хранилището; инстанциира компилирани модули, използвайки <em>JavaScript</em> <em>import</em>-и; извиква изнесените (<em>exported</em>) функции на инстанциираните модули, <em>alias</em>-ва изнесената памет на инстанциираните модули и т.н.</p>
<p><a name="web-modules"></a></p>
<h3 id="модули"><a class="header-link" href="#модули"></a>Модули</h3>
<p>Модулите на <em>WebAssembly</em> позволяват пряка интеграция с модулната система в <em>ES6</em>.</p>
<p><a name="web-modules-names"></a></p>
<h4 id="имена"><a class="header-link" href="#имена"></a>Имена</h4>
<p>Един <em>WebAssembly</em> модул внася и изнася функции.  В <em>WebAssembly</em> имената на функциите са последователности от байтове с неопределена дължина.  Всякакви 8-битови стойности могат да се ползват в <em>WebAssembly</em> име, включително нулев байт и последователности от байтове, които не отговарят на съществуващ <em>code point</em> в Unicode (без значение от кодирането).  Най-естественото представяне в уеб на съпоставяне на имена на функции към функции е JavaScript обект, в който всяка функция е свойство (<em>property</em>).  Имената на свойствата в JavaScript са UTF-16 кодирани низове.  Един <em>WebAssembly</em> модул може да не успее да се валидира в уеб, ако внася или изнася функции, чиито имена не могат да се преобразуват до UTF-16 по следния алгоритъм за преобразуване (ако допуснем, че името в <em>WebAssembly</em> е подадено на аргумента с име <em>array</em> от тип <code>Uint8Array</code>):</p>
<pre class="hljs"><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToJSString</span>(<span class="hljs-params">array</span>)
    </span>{
      <span class="hljs-built_in">var</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)
        <span class="hljs-built_in">string</span> += <span class="hljs-built_in">String</span>.fromCharCode(array[i]);
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-built_in">escape</span>(<span class="hljs-built_in">string</span>));
    }</code></pre><p>Тази функция извършва UTF-8 декодирането (<code>decodeURIComponent(escape(string))</code>), използвайки добре известен JavaScript идиом.  Неуспехът при транскодиране се открива от <code>decodeURIComponent</code>, който може да хвърли <code>URIError</code>.  Ако стане така, <em>WebAssembly</em> модулът няма да успее да се валидира.  Това правило важи само при вграждане в уеб.</p>
<p><a name="web-security"></a></p>
<h3 id="сигурност-1"><a class="header-link" href="#сигурност-1"></a>Сигурност</h3>
<p>Моделът за <a href="#security">сигурност</a> на <em>WebAssembly</em> е изграден върху <em>same-origin</em> принципа, използвайки <em>cross-origin resource sharing</em> (CORS)<sup><a href="#ref-w3c-cors">[32]</a></sup> и интегритет на подресурсите (<em>subresource integrity</em>)<sup><a href="#ref-w3c-sri">[33]</a></sup> с цел постигане на разпределяне през CDN-и (<em>content-distribution networks</em>) и имплементиране на динамично свързване.</p>
<p><a name="web-simd"></a></p>
<h3 id="simd"><a class="header-link" href="#simd"></a>SIMD</h3>
<p>След като се въведе поддръжка за SIMD, <em>WebAssembly</em> ще може (спрямо <code>simd.js</code>):</p>
<ul class="list">
<li>Да бъде статично типизиран, аналогично на <em>SIMD.js-in-asm.js</em>.<sup><a href="#ref-simdjsinasmjs">[34]</a></sup></li>
<li>Да преизползва спецификацията на операционната семантика (с <em>TC39</em>).</li>
<li>Да преизползва бекенд имплементацията (същите <em>IR</em> възли).</li>
</ul>
<p><a name="web-gc"></a></p>
<h3 id="събиране-на-боклука"><a class="header-link" href="#събиране-на-боклука"></a>Събиране на боклука</h3>
<p>След като се въведе поддръжка за <em>събиране на боклука</em> (<em>garbage collection</em>), <em>WebAssembly</em> кодът ще може да реферира и да достъпва JavaScript обекти, DOM обекти и обекти, дефинирани чрез WebIDL.</p>
<p><a name="nonweb"></a></p>
<h2 id="употреба-извън-уеб"><a class="header-link" href="#употреба-извън-уеб"></a>Употреба извън уеб</h2>
<p>Въпреки че <em>WebAssembly</em> е създаден за изпълнение <a href="#web">в уеб среда</a>, е желателно да може той да се изпълнява и в други среди, включително всевъзможни неща като минимални обвивки (<em>shells</em>) за тестване до цялостни приложни среди (например на сървъри в дейтацентрове, на IoT устройства, на мобилни и десктоп приложения).  Желателно е даже да може <em>WebAssembly</em> да се изпълнява като част от по-големи програми.</p>
<p>Средите, различни от уеб, могат да предоставят различни API-та, които могат да бъдат открити и уползотворени чрез тестване за характеристики (<em>feature testing</em>) и динамично свързване (<em>dynamic linking</em>).</p>
<p>Не-уеб средите могат да включват JavaScript виртуални машини (например <code>node.js</code>).  Въпреки това <em>WebAssembly</em> е проектиран така, че да не се нуждае от такава, за да бъде изпълняван.</p>
<p><em>WebAssembly</em> спецификацията сама по себе си не дефинира каквато и да е голяма преносима библиотека от сорта на <em>libc</em>.  Въпреки това някои функции, които са в сърцето на семантиката на <em>WebAssembly</em> и приличат на функции от <em>libc</em>, участват в <em>WebAssembly</em> спецификацията като примитивни оператори (например <code>grow_memory</code>, който прилича на функцията <code>sbrk</code>, налична на множество системи, както и оператори, имащи сходна функционалност с <code>dlopen</code>, които предстои да бъдат добавени).</p>
<p>Когато има припокриване между уеб и не-уеб средите, е най-вероятно да се използва една и съща спецификация, отделна от тази на <em>WebAssembly</em>.  Добър аналог в JavaScript е спецификацията за <em>Loader</em>, която важи както за уеб, така и за <code>node.js</code> среди, и е отделна от спецификацията на JavaScript.</p>
<p>В повечето случаи се очаква да се съдават библиотеки, които имплементират интерфейс към вградените възможности на хоста, с цел преносимост на ниво изходен код.  В този случай <em>WebAssembly</em> ще предоставя функционалности (тестване за характеристики, вградени модули и динамично свързване), чрез които тези библиотеки да могат да се имплементират.  Два класически примера са POSIX и SDL.</p>
<p>Общо взето, поради липсата си на зависимости от уеб API-та, <em>WebAssembly</em> може да се използва като портативен бинарен формат на множество платформи, който носи големи ползи като преносимост, инструменти и езиков агностицизъм (тъй като поддържа семантика на ниво C и C++).</p>
<p><a name="usecases"></a></p>
<h2 id="приложения"><a class="header-link" href="#приложения"></a>Приложения</h2>
<p>Следва неподреден и непълен списък с приложения/предметни области/изчисления, които биха могли да се възползват от <em>WebAssembly</em>:</p>
<p><a name="usecases-browser"></a></p>
<h3 id="в-браузъра"><a class="header-link" href="#в-браузъра"></a>В браузъра</h3>
<ul class="list">
<li>По-добро изпълнение на езици и туулкитове, които в момента се <em>cross-компилират</em>
за уеб (C/C++, GWT, …).</li>
<li>Редкатиране на изображения и видео.</li>
<li>Игри:<ul class="list">
<li>Обикновени игри, които трябва да могат да зареждат бързо.</li>
<li>AAA игри с тежки <em>assets</em>.</li>
<li>Портали за игри.</li>
</ul>
</li>
<li><em>Peer-to-peer</em> приложения (игри, съвместно редактиране и т.н.).</li>
<li>Музикални приложения (стриймващи, кеширащи).</li>
<li>Разпознаване на изображения.</li>
<li>Редактиране на живо видео (например слагане на шапки на главите на хората).</li>
<li>VR и допълнена реалност (<em>augmented reality</em>) (много ниско <em>latency</em>).</li>
<li>CAD приложения.</li>
<li>Научна визуализация и симулация.</li>
<li>Интерактивен образователен софтуер и новинарски статии.</li>
<li>Симулация и емулация на платформи (ARC, DOSBox, QEMU, MAME, …).</li>
<li>Интерпретатори за езици и виртуални машини.</li>
<li>POSIX потребителска среда, която позволява портването на вече съществуващи POSIX приложения.</li>
<li>Инструменти за разработчици (редактори, компилатори, дебъгери, …).</li>
<li>Софтуер за отдалечено управление на компютри (<em>remote desktop</em>).</li>
<li>VPN.</li>
<li>Криптиране.</li>
<li>Локални уеб сървъри.</li>
<li>Софтуер, базиран на NPAPI в рамките на модела за сигурност и API-тата на уеб.</li>
<li>Тежки клиенти за <em>enterprise</em> приложения (например бази данни).</li>
</ul>
<p><a name="usecases-nonbrowser"></a></p>
<h3 id="извън-браузъра"><a class="header-link" href="#извън-браузъра"></a>Извън браузъра</h3>
<ul class="list">
<li>Услуги за разпространение на игри (портативни и сигурни).</li>
<li>Сървърно изчисление на ненадежден код.</li>
<li>Сървърни приложения.</li>
<li>Хибридни <em>native</em> приложения на мобилни устройства.</li>
<li>Симетрични изчисления, обхващащи няколко машини (<em>nodes</em>).</li>
</ul>
<p><a name="usecases-examples"></a></p>
<h3 id="примерни-употреби-на-*webassembly*"><a class="header-link" href="#примерни-употреби-на-*webassembly*"></a>Примерни употреби на <em>WebAssembly</em></h3>
<ul class="list">
<li>Цялата кодова база на <em>WebAssembly</em>.</li>
<li>Основният екран на <em>WebAssembly</em>, но потребителският интерфейс на JavaScript / HTML.</li>
<li>Преизползване на вече съществуващ код чрез ретаргетирането му към <em>WebAssembly</em> и вграждането му в по-голямо JavaScript / HTML приложение.  Това може да е каквото и да е от обикновена <em>helper</em> билбиотека до специално отделени тежки изчисления.</li>
</ul>
<p><a name="ref"></a></p>
<h2 id="източници"><a class="header-link" href="#източници"></a>Източници</h2>
<ol class="list">
<li><a name="ref-website-wasm"></a>Уебсайт на <em>WebAssembly</em>, <a href="http://webassembly.org/">http://webassembly.org/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-website-wasmcg"></a>Уебсайт на <em>WebAssembly Community Group</em>, <a href="https://www.w3.org/community/webassembly/">https://www.w3.org/community/webassembly/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-stackmachine"></a>Wikipedia, <em>Stack machine</em>, <a href="https://en.wikipedia.org/wiki/Stack_machine">https://en.wikipedia.org/wiki/Stack_machine</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-sandbox"></a>Wikipedia, <em>Sandbox</em>, <a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security">https://en.wikipedia.org/wiki/Sandbox_(computer_security</a>), последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-sameorigin"></a>Wikipedia, <em>Same-origin policy</em>, <a href="https://en.wikipedia.org/wiki/Same-origin_policy">https://en.wikipedia.org/wiki/Same-origin_policy</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-mvp"></a>Wikipedia, <em>Minimum viable product</em>, <a href="https://en.wikipedia.org/wiki/Minimum_viable_product">https://en.wikipedia.org/wiki/Minimum_viable_product</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-asmjs"></a>Wikipedia, <em><code>asm.js</code></em>, <a href="https://en.wikipedia.org/wiki/Asm.js">https://en.wikipedia.org/wiki/Asm.js</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-moz-paralleljs"></a>Mozilla JavaScript Blog, <em>The Path to Parallel JavaScript</em>, <a href="https://blog.mozilla.org/javascript/2015/02/26/the-path-to-parallel-javascript/">https://blog.mozilla.org/javascript/2015/02/26/the-path-to-parallel-javascript/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-blinkdev-shbuf"></a><em>blink-dev</em> forum of the <code>chromium.org</code> Google Group, <em>Intent to Implement: Shared Array Buffers</em>, <a href="https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/d-0ibJwCS24">https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/d-0ibJwCS24</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-moz-simdjs"></a>Mozilla Hacks - the Web developer blog, <em>Introducing SIMD.js</em>, <a href="https://hacks.mozilla.org/2014/10/introducing-simd-js/">https://hacks.mozilla.org/2014/10/introducing-simd-js/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-blinkdev-simdjs"></a><em>blink-dev</em> forum of the <code>chromium.org</code> Google Group, <em>Intent to Implement: SIMD.js</em>, <a href="https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/2PIOEJG_aYY">https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/2PIOEJG_aYY</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-w3c-streamsapi"></a><em>W3C</em> Working Group Note, <em>Streams API</em>, <a href="https://www.w3.org/TR/streamsapi/">https://www.w3.org/TR/streamsapi/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-asmjs-aot"></a>Luke Wagner&#39;s blog, <em>asm.js AOT compilation and startup performance</em>, <a href="https://blog.mozilla.org/luke/2014/01/14/asm-js-aot-compilation-and-startup-performance/">https://blog.mozilla.org/luke/2014/01/14/asm-js-aot-compilation-and-startup-performance/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-asmjs-opts"></a>Luke Wagner&#39;s blog, <em>Microsoft announces <code>asm.js</code> optimizations</em>, <a href="https://blog.mozilla.org/luke/2015/02/18/microsoft-announces-asm-js-optimizations/#asmjs-opts">https://blog.mozilla.org/luke/2015/02/18/microsoft-announces-asm-js-optimizations/#asmjs-opts</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-spec"></a>GitHub.com, <em>Staging ground for artifacts related to an MVP spec</em>, <a href="https://github.com/WebAssembly/spec">https://github.com/WebAssembly/spec</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-design-datatypes"></a>GitHub.com, <em>WebAssembly Design Documents: Data Types</em>, <a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#data-types">https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#data-types</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-design-modulestructure"></a>GitHub.com, <em>WebAssembly Design Documents: Module Structure</em>, <a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#module-structure">https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#module-structure</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-sexpr"></a>Wikipedia, <em>S-expression</em>, <a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-twoscompl"></a>Wikipedia, <em>Two&#39;s complement</em>, <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement">https://en.wikipedia.org/wiki/Two&#39;s_complement</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-owp"></a>Wikipedia, <em>Open Web Platform</em>, <a href="https://en.wikipedia.org/wiki/Open_Web_Platform">https://en.wikipedia.org/wiki/Open_Web_Platform</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-posix"></a>Wikipedia, <em>POSIX</em>, <a href="https://en.wikipedia.org/wiki/POSIX">https://en.wikipedia.org/wiki/POSIX</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-w3c-sop"></a><em>W3C</em> Web Security Wiki, <em>Same Origin Policy</em>, <a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">https://www.w3.org/Security/wiki/Same_Origin_Policy</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-cfi"></a>Microsoft Research, <em>Control-Flow Integrity</em>, <a href="https://research.microsoft.com/apps/pubs/default.aspx?id=64250">https://research.microsoft.com/apps/pubs/default.aspx?id=64250</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-execprot"></a>Wikipedia, <em>Executable space protection</em>, <a href="https://en.wikipedia.org/wiki/Executable_space_protection">https://en.wikipedia.org/wiki/Executable_space_protection</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-randcanaries"></a>Wikipedia, <em>Buffer overflow protection: Random canaries</em>, <a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Random_canaries">https://en.wikipedia.org/wiki/Buffer_overflow_protection#Random_canaries</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-rop"></a>Wikipedia, <em>Return-oriented programming</em>, <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">https://en.wikipedia.org/wiki/Return-oriented_programming</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-toctou"></a>Wikipedia, <em>Time of check to time of use</em>, <a href="https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use">https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-sidechan"></a>Wikipedia, <em>Side-channel attack</em>, <a href="https://en.wikipedia.org/wiki/Side-channel_attack">https://en.wikipedia.org/wiki/Side-channel_attack</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-aslr"></a>Wikipedia, <em>Address space layout randomization</em>, <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-wp-boundedptr"></a>Wikipedia, <em>Bounded pointer</em>, <a href="https://en.wikipedia.org/wiki/Bounded_pointer">https://en.wikipedia.org/wiki/Bounded_pointer</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-w3c-cors"></a><em>W3C</em> Recommendation, <em>Cross-Origin Resource Sharing</em>, <a href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-w3c-sri"></a><em>W3C</em> Recommendation, <em>Subresource Integrity</em>, <a href="https://www.w3.org/TR/SRI/">https://www.w3.org/TR/SRI/</a>, последно посетен на 2017-01-12.</li>
<li><a name="ref-simdjsinasmjs"></a>Web Incubator Community Group (WICG), <em>Request For Comments: SIMD.js in asm.js</em>, <a href="https://discourse.wicg.io/t/request-for-comments-simd-js-in-asm-js/676">https://discourse.wicg.io/t/request-for-comments-simd-js-in-asm-js/676</a>, последно посетен на 2017-01-12.</li>
</ol>
</body>
</html>
